# Drivebase Engineering Rules

This file is the canonical engineering ruleset for agents working in `drivebase`.

## Overview

Drivebase is a cloud-agnostic file management system built as a Bun monorepo. Users can connect multiple storage providers (S3, Google Drive, Dropbox, FTP, WebDAV, Telegram, Local) and manage files through a unified virtual folder structure.

**Core Stack**: Bun, TypeScript, GraphQL Yoga, Drizzle ORM (PostgreSQL), React (TanStack Router, urql, Zustand), BullMQ (Redis)

## Architecture

### Monorepo Structure

```
packages/
  core/          - Shared types, IStorageProvider interface, custom errors
  db/            - Drizzle schema, migrations, database client
  {provider}/    - Storage provider implementations (google-drive, s3, local, etc.)
apps/
  api/           - GraphQL server (Bun.serve), provider routes, upload worker
  web/           - React SPA with feature-based architecture
```

### Storage Provider System

**Key Concept**: All providers implement `IStorageProvider` from `@drivebase/core`. Files have both a virtual path (user-facing) and provider-specific `remoteId`.

- **Registration**: Each provider exports a `ProviderRegistration` object registered in `apps/api/config/providers.ts`
- **Credentials**: Encrypted with AES-256-GCM (see `apps/api/utils/encryption.ts`) before storing in DB
- **Instance Lifecycle**: Always call `provider.cleanup()` after operations to release resources
- **Upload/Download Flow**: Providers return presigned URLs when supported, otherwise proxy through API endpoints (`/api/upload/proxy`, `/api/download/proxy`)

Provider package structure:
```
packages/{provider}/
├── index.ts        // Exports registration and provider class
├── provider.ts     // Implements IStorageProvider
├── schema.ts       // Zod schema for config validation
└── oauth.ts        // OAuth helpers (if needed)
```

### Upload Flow

**Two-phase upload for proxy providers**:
1. **Client → API**: Chunked multipart upload to `/api/upload/proxy/:sessionId` (Bearer auth)
2. **API → Provider**: BullMQ worker (`apps/api/queue/upload-worker.ts`) transfers assembled file to provider

- Session tracking via `upload_sessions` table with upload/transfer status
- Progress events published via GraphQL subscriptions (GraphQL Yoga SSE)
- Cleanup failed records if provider transfer fails

Direct upload flow (S3): Client gets presigned URL from `requestUpload`, uploads directly to provider.

## 1) Core Principles

- Keep domains isolated. Do not mix unrelated business logic in the same module.
- Preserve behavior unless requirements explicitly call for behavior changes.
- Prefer DDD-style boundaries: each domain owns its models, operations, and orchestration.
- Separate read and write paths clearly.
- Keep files focused and composable; one file should have one primary responsibility.

## 2) Runtime and Tooling

- Bun-first workflow:
  - Use `bun <file>` (not `node`/`ts-node`).
  - Use `bun test` for tests.
  - Use `bun install` for dependencies.
  - Use `bun run <script>` for scripts.
  - Use `bunx <pkg> <cmd>` instead of `npx`.
- Do not add `dotenv` unless explicitly required.

### Bun-Specific Patterns

```typescript
// File I/O
const file = Bun.file("path/to/file");
await Bun.write("output.txt", data);

// Process spawning (prefer over execa)
await Bun.$`ls -la`;

// Built-in WebSocket (no 'ws' package)
// Built-in .env loading (no dotenv)
```

### Essential Commands

```bash
# Install dependencies
bun install

# Development (runs both API and web)
bun run dev

# Type checking (CI requirement: zero errors)
bunx tsc --noEmit

# Database operations
bun run db:generate --name <migration_name>  # Generate migration after schema change (always use --name)
bun run db:migrate     # Apply pending migrations
bun run db:studio      # Open Drizzle Studio

# GraphQL codegen (after schema changes)
cd apps/api && bun run codegen
cd apps/web && bun run codegen

# Format/lint
bun run format
bun run check
```

### Environment Setup

Copy `.env.example` to `.env.local` and set:
- `DATABASE_URL`, `REDIS_URL`
- `JWT_SECRET`, `ENCRYPTION_KEY` (32+ chars)
- `API_BASE_URL`, `CORS_ORIGIN`
- Provider-specific OAuth credentials (e.g., `GOOGLE_CLIENT_ID`)

## 3) Monorepo Boundaries

- `apps/api`: GraphQL API, domain services, workers.
- `apps/web`: frontend app (TanStack Router + React + urql).
- `packages/*`: shared reusable packages only (`db`, `core`, `utils`, provider SDKs).

Do not place app-specific logic into shared packages unless it is genuinely reusable.

## 4) API Architecture (`apps/api`)

### 4.1 Schema-first GraphQL

- GraphQL schema is source of truth (`apps/api/graphql/schema/*.graphql`).
- Keep resolver signatures aligned with generated types.
- Keep schema and resolver behavior backward compatible unless explicitly requested otherwise.
- Run codegen and typecheck after schema/document changes.
- Context type: `GraphQLContext` has `db`, `user` (authenticated JWT payload or null), `headers`, `ip`
- Authentication: Check `context.user`, throw `NotFoundError("User not found")` if required
- Use generated types from `graphql/generated/types.ts`

### 4.2 Resolver and Service Responsibilities

- Resolvers must remain thin orchestration layers.
- Business logic belongs in `apps/api/service/**`.
- Keep resolvers domain-scoped (`activity.ts`, `provider.ts`, `workspace.ts`, etc.).
- Orchestrators may live in top-level domain service files and compose query/mutation modules.

### 4.3 Required Domain Split

Within each domain service:

- `query/` for reads.
- `mutation/` for writes and side-effects.
- `shared/` for reusable internal helpers/types only.
- `index.ts` as explicit domain export boundary.

### 4.4 API Safety and Consistency

- Use shared typed errors from `@drivebase/core` (`ValidationError`, `NotFoundError`, `ConflictError`, etc.):

```typescript
import { NotFoundError, ValidationError, ProviderError } from "@drivebase/core";

throw new NotFoundError("File not found");
throw new ValidationError("Invalid file name");
throw new ProviderError("google_drive", "Upload failed", { details }); // provider type is first param
```

- Always clean up provider/resources in `finally` blocks (`provider.cleanup()`, streams, handles).
- Use Drizzle ORM patterns consistently and preserve soft-delete behavior where present.

### 4.5 Job vs Activity Semantics

- `jobs`: realtime mutable execution progress (pending/running/completed/error, progress `0..1`).
- `activities`: immutable history/messages (success/error/info/completion summaries).
- Realtime panels consume jobs; history views consume activities.

### 4.6 Creating a New Storage Provider

See `.claude/skills/create-provider/SKILL.md` for full guide. Key steps:
1. Create `packages/{provider}/` with `provider.ts` implementing `IStorageProvider`
2. Define `schema.ts` (Zod) and export `{Provider}SensitiveFields`
3. Export `{provider}Registration` in `index.ts`
4. Register in `apps/api/config/providers.ts`
5. Add GraphQL schema if custom auth flow needed

## 5) Web Architecture (`apps/web`)

### 5.1 Routes, Hooks, and Domain Logic

- Keep routes thin (`src/routes/**`).
- Put domain logic in feature hooks/services/stores (`src/features/**`, `src/shared/**`).
- One hook per data concern; avoid mega-hooks spanning unrelated domains.

Feature-based structure:
```
features/
  {domain}/
    api/         - GraphQL queries/mutations
    hooks/       - Business logic hooks (useFiles, useProviders, etc.)
    components/  - Feature-specific components
    store/       - Zustand stores (if needed)
    index.ts     - Barrel export
```

Example:
```typescript
// features/files/hooks/useFileOperations.ts
export function useFileOperations() {
  const [, deleteFile] = useMutation(DELETE_FILE_MUTATION);
  const [, starFile] = useMutation(STAR_FILE_MUTATION);
  // ... return operations
}

// routes/files/$path.tsx
function FilesRoute() {
  const [contents] = useContents(path);
  const ops = useFileOperations();
  return <FilesTable data={contents.data} operations={ops} />;
}
```

### 5.2 UI and State Management

- Component files focus on rendering and interaction.
- Move reusable complexity to colocated util files (e.g. `*Utils.ts`).
- Keep Zustand actions minimal, deterministic, and typed.
- Avoid implicit cross-domain writes in a single action.
- Preserve UX stability (avoid layout flicker, keep action placement consistent).
- All user-facing UI strings must use Lingui (`Trans` or equivalent wrappers).
- Use shadcn/ui components from `components/ui/` — never create custom base UI components.
- For confirmation dialogs, use `confirmDialog(title, description)` from `@/shared/lib/confirmDialog` — never use `window.confirm` or inline `AlertDialog` for this purpose.
- For prompt dialogs, use `promptDialog(title, description)` from `@/shared/lib/promptDialog` (if it exists) — never use `window.prompt` or inline dialogs.
- Do not import `AlertDialog` or similar primitives directly into feature components just for confirmation — use the shared utilities above.
- Tailwind CSS v4 via `@tailwindcss/vite` for all styling; never inline custom styles.
- Use `cn()` from `@/shared/lib/utils` for conditional className merging:
  ```typescript
  import { cn } from "@/shared/lib/utils";
  <div className={cn("base-classes", condition && "conditional-classes")} />
  ```
- Use CVA (class-variance-authority) for component variants, matching existing button/input patterns.
- Layout components go in `components/layout/`, reusable UI primitives in `components/ui/`.
- Use `@/shared/hooks/useOptimisticList` for lists with mutations.

### 5.3 Data Table Patterns

Files UI uses `@tanstack/react-table` with:
- Row selection (checkbox column, fixed width)
- Column visibility toggle
- Actions menu (three-dot menu, right-aligned)
- Keep toolbar visible during loading states to avoid layout shift

### 5.4 Authentication & Session

- JWT stored in `localStorage` (web) or Redis session (API)
- Bearer token in `Authorization: Bearer {token}` header
- Cookie fallback for SSE subscriptions
- Auth bootstrap: Never show dashboard UI before `useMe` query resolves

## 6) TypeScript and Imports

- Strict typing required.
- Do not introduce `any`.
- Do not use non-null assertions (`!`) to bypass checks — validate and throw errors.
- Convert `null` to `undefined` for optional params: `value ?? undefined`
- Validate inputs and throw descriptive errors.
- Exported functions should have explicit, clear return behavior.
- Prefer typed helpers over inline casts.
- Use configured path aliases (including `@/*` where configured) over deep relative imports.
- Use `index.ts` barrels at module/domain boundaries only.
- Avoid circular imports and `export-file.ts` style surfaces.

## 7) File and Refactor Standards

- Keep naming consistent with domain language (including singular/plural conventions).
- For large domains, prefer one exported function per file where practical.
- Keep touched non-generated source files near or below 200 LOC when practical.
- Generated files are exempt.
- Add short comments only when needed; avoid obvious narration.
- Remove obsolete files after replacement and update imports in the same change.

## 8) Data and Persistence

- Schema changes must update `packages/db/schema/*`.
- Schema changes must include migrations generated via drizzle-kit — **never write migration SQL by hand**:
  ```bash
  bun run db:generate --name <descriptive_name>
  ```
- Never manually edit generated migration SQL files or `meta/_journal.json`.
- For new required fields, use safe rollout: nullable → backfill → enforce not null.
- Never clear persisted history for UI-only behavior unless explicitly requested.
- Soft deletes: Set `isDeleted: true` instead of hard-deleting records.
- Always check for undefined: `if (!result) throw new NotFoundError("...")`

## 9) Quality Gates

Before finishing:

- Run codegen if GraphQL schema/documents changed.
- Run typechecks for touched areas:
  - `bunx tsc --noEmit -p apps/web/tsconfig.json`
  - `bunx tsc --noEmit -p apps/api/tsconfig.json`
- Run targeted tests for touched domains.
- Run GraphQL regression tests when resolver/service internals changed.
- If failures are pre-existing, report them explicitly and do not mask them.

### Testing Strategy

- Use `bun test` (built-in test runner, Jest-compatible API)
- Test files: `*.test.ts` adjacent to source files
- Provider tests: Mock provider SDK, test `IStorageProvider` contract compliance
- Integration tests: Real DB/Redis via Docker Compose

## 10) Change Hygiene

- Keep changes scoped and reviewable.
- Do not mix unrelated refactors with behavior changes unless asked.
- Maintain backward compatibility unless migration is intentional and documented.
- Document assumptions and follow-ups when deferring work.
- Prefer conventional commits with accurate scope (`feat`, `fix`, `refactor`, `chore`, etc.).

## Common Pitfalls

1. **Forgetting codegen**: GraphQL schema changes require running `bun run codegen` in both API and web
2. **Direct file mutations**: Use mutations with optimistic updates, not manual cache updates
3. **Provider cleanup**: Always call `provider.cleanup()` in finally blocks
4. **Manual migrations**: Never write migration SQL by hand — always use `bun run db:generate --name <name>`
5. **Route business logic**: Keep routes thin — move logic to hooks in `features/`
6. **Session cleanup**: Failed uploads must cleanup DB records and temp files
7. **File size**: Split files exceeding 300 LoC into focused modules
8. **UI inconsistency**: Always use existing shadcn/ui components, never create custom base components
9. **Inline confirm/prompt dialogs**: Use `confirmDialog` / `promptDialog` from `@/shared/lib/` — never `window.confirm`, `window.prompt`, or raw `AlertDialog` imports in feature components

## Key Files to Reference

- Storage interface: `packages/core/interfaces.ts`
- Provider registry: `apps/api/config/providers.ts`
- GraphQL context: `apps/api/graphql/context.ts`
- Upload worker: `apps/api/queue/upload-worker.ts`
- Web hooks pattern: `apps/web/src/features/files/hooks/useFiles.ts`
- Encryption utils: `apps/api/utils/encryption.ts`
- Confirm dialog utility: `apps/web/src/shared/lib/confirmDialog.tsx`
