# Drivebase Engineering Rules

This file is the canonical engineering ruleset for agents working in `drivebase`.

## 1) Core Principles

- Keep domains isolated. Do not mix unrelated business logic in the same module.
- Preserve behavior unless requirements explicitly call for behavior changes.
- Prefer DDD-style boundaries: each domain owns its models, operations, and orchestration.
- Separate read and write paths clearly.
- Keep files focused and composable; one file should have one primary responsibility.

## 2) Runtime and Tooling

- Bun-first workflow:
- Use `bun <file>` (not `node`/`ts-node`).
- Use `bun test` for tests.
- Use `bun install` for dependencies.
- Use `bun run <script>` for scripts.
- Use `bunx <pkg> <cmd>` instead of `npx`.
- Do not add `dotenv` unless explicitly required.

## 3) Monorepo Boundaries

- `apps/api`: GraphQL API, domain services, workers.
- `apps/web`: frontend app (TanStack Router + React + urql).
- `packages/*`: shared reusable packages only (`db`, `core`, `utils`, provider SDKs).

Do not place app-specific logic into shared packages unless it is genuinely reusable.

## 4) API Architecture (`apps/api`)

### 4.1 Schema-first GraphQL

- GraphQL schema is source of truth (`apps/api/graphql/schema/*.graphql`).
- Keep resolver signatures aligned with generated types.
- Keep schema and resolver behavior backward compatible unless explicitly requested otherwise.
- Run codegen and typecheck after schema/document changes.

### 4.2 Resolver and Service Responsibilities

- Resolvers must remain thin orchestration layers.
- Business logic belongs in `apps/api/service/**`.
- Keep resolvers domain-scoped (`activity.ts`, `provider.ts`, `workspace.ts`, etc.).
- Orchestrators may live in top-level domain service files and compose query/mutation modules.

### 4.3 Required Domain Split

Within each domain service:

- `query/` for reads.
- `mutation/` for writes and side-effects.
- `shared/` for reusable internal helpers/types only.
- `index.ts` as explicit domain export boundary.

### 4.4 API Safety and Consistency

- Use shared typed errors from `@drivebase/core` (`ValidationError`, `NotFoundError`, `ConflictError`, etc.).
- Always clean up provider/resources in `finally` blocks (`provider.cleanup()`, streams, handles).
- Use Drizzle ORM patterns consistently and preserve soft-delete behavior where present.

### 4.5 Job vs Activity Semantics

- `jobs`: realtime mutable execution progress (pending/running/completed/error, progress `0..1`).
- `activities`: immutable history/messages (success/error/info/completion summaries).
- Realtime panels consume jobs; history views consume activities.

## 5) Web Architecture (`apps/web`)

### 5.1 Routes, Hooks, and Domain Logic

- Keep routes thin (`src/routes/**`).
- Put domain logic in feature hooks/services/stores (`src/features/**`, `src/shared/**`).
- One hook per data concern; avoid mega-hooks spanning unrelated domains.

### 5.2 UI and State Management

- Component files focus on rendering and interaction.
- Move reusable complexity to colocated util files (for example `*Utils.ts`).
- Keep Zustand actions minimal, deterministic, and typed.
- Avoid implicit cross-domain writes in a single action.
- Preserve UX stability (avoid layout flicker, keep action placement consistent).
- All user-facing UI strings must use Lingui (`Trans` or equivalent wrappers).

## 6) TypeScript and Imports

- Strict typing required.
- Do not introduce `any`.
- Do not use non-null assertions to bypass checks.
- Validate inputs and throw descriptive errors.
- Exported functions should have explicit, clear return behavior.
- Prefer typed helpers over inline casts.
- Use configured path aliases (including `@/*` where configured) over deep relative imports.
- Use `index.ts` barrels at module/domain boundaries only.
- Avoid circular imports and `export-file.ts` style surfaces.

## 7) File and Refactor Standards

- Keep naming consistent with domain language (including singular/plural conventions).
- For large domains, prefer one exported function per file where practical.
- Keep touched non-generated source files near or below 200 LOC when practical.
- Generated files are exempt.
- Add short comments only when needed; avoid obvious narration.
- Remove obsolete files after replacement and update imports in the same change.

## 8) Data and Persistence

- Schema changes must update `packages/db/schema/*`.
- Schema changes must include migrations in `packages/db/migrations/*` (unless explicitly told otherwise).
- Update migration journal when required.
- For new required fields, use safe rollout: nullable -> backfill -> enforce not null.
- Never clear persisted history for UI-only behavior unless explicitly requested.

## 9) Quality Gates

Before finishing:

- Run codegen if GraphQL schema/documents changed.
- Run typechecks for touched areas:
- `bunx tsc --noEmit -p apps/web/tsconfig.json`
- `bunx tsc --noEmit -p apps/api/tsconfig.json`
- Run targeted tests for touched domains.
- Run GraphQL regression tests when resolver/service internals changed.
- If failures are pre-existing, report them explicitly and do not mask them.

## 10) Change Hygiene

- Keep changes scoped and reviewable.
- Do not mix unrelated refactors with behavior changes unless asked.
- Maintain backward compatibility unless migration is intentional and documented.
- Document assumptions and follow-ups when deferring work.
- Prefer conventional commits with accurate scope (`feat`, `fix`, `refactor`, `chore`, etc.).
