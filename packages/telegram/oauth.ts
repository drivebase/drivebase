import type { OAuthInitResult, ProviderConfig } from "@drivebase/core";
import { ProviderError } from "@drivebase/core";
import type { TelegramConfig } from "./schema";
import { TelegramConfigSchema } from "./schema";

function parseConfig(config: ProviderConfig): TelegramConfig {
	const parsed = TelegramConfigSchema.safeParse(config);
	if (!parsed.success) {
		throw new ProviderError("telegram", "Invalid Telegram configuration", {
			errors: parsed.error.errors,
		});
	}
	return parsed.data;
}

/**
 * Initiate the Telegram auth flow.
 *
 * Unlike standard OAuth, Telegram uses phone + OTP + optional 2FA.
 * We redirect the user to our own /connect/telegram page in apps/web,
 * which handles the interactive login flow using GramJS.
 *
 * The state parameter carries `<providerId>:<csrfToken>` â€” passed through unchanged.
 */
export async function initiateTelegramOAuth(
	config: ProviderConfig,
	_callbackUrl: string,
	state: string,
): Promise<OAuthInitResult> {
	const { apiId, apiHash } = parseConfig(config);

	// Build URL to our custom Telegram login page.
	// The web app reads apiId/apiHash from the provider config via API,
	// so we only pass the state for routing.
	const params = new URLSearchParams({
		state,
		apiId: String(apiId),
		apiHash,
	});

	const authorizationUrl = `/connect/telegram?${params.toString()}`;

	return { authorizationUrl, state };
}

/**
 * Handle the Telegram auth callback.
 *
 * The "code" parameter here is actually the GramJS session string
 * generated by the /connect/telegram page after successful phone/OTP/2FA auth.
 */
export async function handleTelegramOAuthCallback(
	config: ProviderConfig,
	code: string,
	_callbackUrl: string,
): Promise<ProviderConfig> {
	if (!code || code.trim().length === 0) {
		throw new ProviderError(
			"telegram",
			"No session string received from Telegram auth flow",
		);
	}

	return {
		...config,
		sessionString: code,
	};
}
